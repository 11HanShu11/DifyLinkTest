{"__main_SugorokuModel_cs": "using UnityEngine;\n\npublic class SugorokuModel : MonoBehaviour\n{\n    public int DiceValue { get; set; }\n    public int DiceTotal { get; set; }\n    public int PieceTileIndex { get; set; }\n}\n", "__main_TileManager_cs": "using System.Collections.Generic;\nusing UnityEngine;\nusing DG.Tweening;\n\npublic class TileManager : MonoBehaviour\n{\n    private const string SHDER_PROPERTY_TEX_1 = \"_Tex_1\";\n    private const string SHDER_PROPERTY_TEX_2 = \"_Tex_2\";\n    private const float JUMP_TIME = 0.07f;\n\n    [SerializeField] private List<GameObject> _tiles = new();\n    [SerializeField] private Material _roadMaterial;\n    [SerializeField] private List<Texture> _setTextures;\n    [SerializeField] private Texture _defaultTextures;\n    [SerializeField] private Shader _tileChange;\n\n    private List<Material> materials = new();\n    private int _changedCount;\n\n    public List<GameObject> Tiles => _tiles;\n\n    private void Awake()\n    {\n        SettingMaterialTile();\n    }\n\n    /// <summary>\n    /// タイルObjにマテリアルを設定する\n    /// </summary>\n    private void SettingMaterialTile()\n    {\n        foreach (var tile in _tiles)\n        {\n            var renderer = tile.GetComponent<Renderer>();\n            if (renderer != null && renderer.material != null)\n            {\n                Material newMat = new Material(_tileChange);\n                newMat.SetTexture(SHDER_PROPERTY_TEX_1, _defaultTextures);\n                renderer.material = newMat;\n\n                materials.Add(renderer.material);\n            }\n            else\n            {\n                Debug.LogWarning($\"{tile.name} に Renderer または Material が設定されていません。\");\n                materials.Add(null); // nullで埋めておくか、スキップも可\n            }\n        }\n    }\n\n    private void OnDisable()\n    {\n        RoadMoving(false);\n    }\n\n    /// <summary>\n    /// 中心FloorのMaterialをPieceの場所により変化\n    /// </summary>\n    public Tween ChangeRoadVisual(float time, int walkCount)\n    {\n        bool isEvenStep = walkCount % 2 == 0;\n        float fromValue = isEvenStep ? 1f : 0f;\n        float toValue = 1f - fromValue;\n\n        return DOVirtual.Float(\n        from: fromValue,\n        to: toValue,\n        duration: time,\n            onVirtualUpdate: (tweenValue) =>\n            {\n                _roadMaterial.SetFloat(\"_ChangeValue\", tweenValue);\n            }).OnStart(() =>\n            {\n                ApplyRoadMaterialChange();\n            });\n    }\n\n    /// <summary>\n    /// マテリアルの変更処理\n    /// _roadMaterialを適宜変更する\n    /// </summary>\n    private void ApplyRoadMaterialChange()\n    {\n        _changedCount++;\n\n        int matIndex = _changedCount % materials.Count;\n        Material tileMat = materials[matIndex];\n        float tileValue = tileMat.GetFloat(\"_ChangeValue\");\n\n        string tileTexProp = tileValue == 0f ? SHDER_PROPERTY_TEX_1 : SHDER_PROPERTY_TEX_2;\n        Texture newTex = tileMat.GetTexture(tileTexProp);\n\n        string targetTexProp = (_changedCount % 2 == 0) ? SHDER_PROPERTY_TEX_1 : SHDER_PROPERTY_TEX_2;\n        _roadMaterial.SetTexture(targetTexProp, newTex);\n    }\n\n    /// <summary>\n    /// タイルの更新\n    /// </summary>\n    /// <param name=\"number\">進行数</param>\n    public void UpdateTiles()\n    {\n        Sequence sequence = DOTween.Sequence();\n\n        for (int i = 0; i < _tiles.Count; i++)\n        {\n\n            Transform _moveTrans = _tiles[i].transform;\n            Vector3 setPos = _moveTrans.position;\n\n            sequence.Append(_moveTrans.transform.DOJump(setPos, .7f, 1, JUMP_TIME));\n            sequence.Join(ChangeTile(JUMP_TIME, materials[i]));\n        }\n\n        sequence.Play();\n    }\n\n    /// <summary>\n    /// マテリアルのテクスチャ変更\n    /// </summary>\n    /// <param name=\"time\"></param>\n    /// <param name=\"mate\"></param>\n    /// <returns></returns>\n    public Tween ChangeTile(float time, Material mate)\n    {\n        float to = 0;\n\n        string propertyName = \"\";\n        var value = mate.GetFloat(\"_ChangeValue\");\n\n        if (value == 0)\n        {\n            propertyName = SHDER_PROPERTY_TEX_2;\n            to = 1;\n        }\n        else\n        {\n            propertyName = SHDER_PROPERTY_TEX_1;\n            to = 0;\n        }\n\n        int rnd = Random.Range(0, _setTextures.Count);\n        mate.SetTexture(propertyName, _setTextures[rnd]);\n\n        return DOVirtual.Float(\n            from: value,\n            to: to,\n            duration: time,\n            onVirtualUpdate: (tweenValue) =>\n            {\n                mate.SetFloat(\"_ChangeValue\", tweenValue);\n            });\n    }\n\n    /// <summary>\n    /// 中心の床を動作有無\n    /// </summary>\n    public void RoadMoving(bool isMoving)\n    {\n        Vector2 speed = (isMoving) ? new Vector2(0f, -2f) : Vector2.zero;\n        _roadMaterial.SetVector(\"_Speed\", speed);\n    }\n}\n\n\n", "__main_PieceMoving_cs": "using System;\nusing UnityEngine;\nusing System.Collections.Generic;\nusing DG.Tweening;\nusing Cysharp.Threading.Tasks;\nusing UnityEngine.UI;\nusing UniRx;\n\npublic class PieceMoving : MonoBehaviour\n{\n    private const float JUMP_POWER = 0.6f; //ジャンプ力\n    private const float JUMP_TIME = 0.2f; //移動時間\n\n    [SerializeField] private Transform _pieceTrans;\n\n    public List<GameObject> Tiles { private get; set; }\n    public int CurrentTileIndex => _currentTileIndex;\n    public ReactiveProperty<bool> IsPieceMove = new ReactiveProperty<bool>(false);\n    public IObservable<(float, int)> RoadChange => _roadChange;\n    public IObservable<Unit> GetTile => _getTile;\n\n    private int _currentTileIndex = 0;\n    private readonly Subject<(float, int)> _roadChange = new Subject<(float, int)>();\n    private readonly Subject<Unit> _getTile = new Subject<Unit>();\n\n    void Start()\n    {\n        _getTile.OnNext(Unit.Default);\n        // TimeScaleController.Instance.SetTimeScale(\"Slow\", 0.2f);\n        // DOVirtual.DelayedCall(5f, () => TimeScaleController.Instance.ClearTimeScale(\"Slow\"));  \n    }\n\n    /// <summary>\n    /// 移動とアニメーション\n    /// </summary>\n    /// <param name=\"number\">進行数</param>\n    public void ProceedPiece(int number)\n    {\n        Sequence sequence = DOTween.Sequence();\n\n        IsPieceMove.Value = true;\n        for (int i = 0; i < number; i++)\n        {\n            _currentTileIndex++;\n\n            Vector3 nextPos = NextPos(_currentTileIndex);\n\n            sequence.Append(_pieceTrans.transform.DOJump(nextPos, JUMP_POWER, 1, JUMP_TIME));\n            sequence.AppendCallback(() => _roadChange.OnNext((JUMP_TIME, _currentTileIndex)));\n        }\n\n        sequence.OnComplete(() =>\n            {\n                Debug.Log(\"アニメーションが終了しました\");\n                IsPieceMove.Value = false;\n            });\n\n        sequence.Play();\n    }\n\n    /// <summary>\n    /// 進行位置の決定\n    /// </summary>\n    /// <param name=\"number\">歩数合計</param>\n    /// <returns = Vector3> 進行位置</returns>\n    private Vector3 NextPos(int tileIndex)\n    {\n        _currentTileIndex = tileIndex % (Tiles.Count);\n\n        var tilePos = Tiles[_currentTileIndex].transform.position;\n        tilePos.y += 1;\n\n        return tilePos;\n    }\n\n}\n", "__main_SugorokuAnime_cs": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing Cysharp.Threading.Tasks;\nusing DG.Tweening;\n\npublic class SugorokuAnime : MonoBehaviour\n{\n    [SerializeField] private List<Button> _buttons;\n    [SerializeField] private Animator _anime;\n    [SerializeField] private Transform _playerPos;\n\n    private int _previousSign = 0; // -1, 0, 1 を格納\n    private string[] _animationNames = { \"Run2_R\", \"Run2_L\", \"Parkour001_L\", \"Drift_L\", \"GoalPerformance_Kawaii_A\", \"Brake\"};\n    private string[] _selectedAnimationName = { \"Run_R\", \"Run_L\" };\n    private const float FADE_TIME = 0.2f;\n    private bool _isRunning = false;\n\n    void Start()\n    {\n        SettingButtons();\n        _anime.Play(_animationNames[5]);\n    }\n    \n    /// <summary>\n    /// 開始アニメーション\n    /// 開始カウントダウン終了で実行\n    /// </summary>\n    /// <returns></returns>\n    public async UniTask StartAnimation()\n    {\n        DefaultAnimation(_previousSign);// 開始時にループ再生\n        await UniTask.Delay(TimeSpan.FromSeconds(3));\n        StartRandomMovement().Forget(); // 非同期で動作開始\n    }\n\n    private void SettingButtons()\n    {\n        int smaller = Mathf.Min(_buttons.Count, _animationNames.Length);\n\n        for (int i = 0; i < smaller; i++)\n        {\n            int index = i; // クロージャ対策\n            _buttons[i].onClick.AddListener(() => _ = PlayTemporaryAnimation(_animationNames[index]));\n        }\n    }\n\n    private async UniTaskVoid PlayTemporaryAnimation(string clipName)\n    {\n        StopAllCoroutines(); // 複数押されたときの処理衝突防止\n        await PlayAndReturnToDefault(clipName);\n    }\n\n    private async UniTask PlayAndReturnToDefault(string clipName)\n    {\n        _anime.CrossFade(clipName, FADE_TIME);\n\n        // CrossFadeによって状態が切り替わるのを待つ（次のフレーム）\n        await UniTask.Yield();\n\n        // 状態が正しく更新されるまで少し待機\n        await UniTask.WaitUntil(() => _anime.GetCurrentAnimatorStateInfo(0).IsName(clipName));\n\n        AnimatorStateInfo state = _anime.GetCurrentAnimatorStateInfo(0);\n        float length = state.length;\n\n        // 念のため、length分+α待つ（途中で切れるのを防ぐ）\n        await UniTask.Delay(TimeSpan.FromSeconds(length + 0.1f));\n\n        // 元のループアニメーションに戻す\n        DefaultAnimation(_previousSign);\n    }\n\n\n\n    #region ループアニメ処理\n    private async UniTaskVoid StartRandomMovement()\n    {\n        _isRunning = true;\n\n        while (_isRunning)\n        {\n            // ランダムな方向を取得\n            int rndmMoveX = UnityEngine.Random.Range(-3, 3);\n            int rndmMoveZ = UnityEngine.Random.Range(-2, 2);\n\n            _playerPos.DOMoveX(rndmMoveX, 2);\n            _playerPos.DOMoveZ(rndmMoveZ, 2);\n            DefaultAnimation(rndmMoveX);\n\n            // ランダムな待機時間\n            float waitTime = UnityEngine.Random.Range(3, 5);\n            await UniTask.Delay(TimeSpan.FromSeconds(waitTime));\n        }\n    }\n\n    /// <summary>\n    /// プレイヤーのアニメーター実行\n    /// </summary>\n    /// <param name=\"newSign\"></param>\n    private void DefaultAnimation(int newSign)\n    {\n        if (newSign <= 0)\n        {\n            _anime.CrossFade(_selectedAnimationName[0], FADE_TIME);\n        }\n        else\n        {\n            _anime.CrossFade(_selectedAnimationName[1], FADE_TIME);\n        }\n    }\n    #endregion\n\n}\n", "__main_GameOpening_cs": "using UnityEngine;\nusing UniRx;\nusing Cysharp.Threading.Tasks;\nusing System;\nusing DG.Tweening;\nusing TMPro;\n\npublic class GameOpening : MonoBehaviour\n{\n    [Header(\"References\")]\n    [SerializeField] private Transform _cameraTrans;\n    [SerializeField] private TMP_Text _countTxt;\n\n    private Vector3 _initialPos;\n    private Vector3 _initialRot;\n\n    private readonly Subject<Unit> _openingEnd = new();\n    public IObservable<Unit> OpeningEnd => _openingEnd;\n\n    private readonly Subject<Unit> _tileChange = new();\n    public IObservable<Unit> TileChange => _tileChange;\n\n    private readonly Subject<Unit> _goSignal = new();\n    public IObservable<Unit> GoSignal => _goSignal;\n\n    private void Start()\n    {\n        // 開始時の状態を保存\n        _initialPos = _cameraTrans.position;\n        _initialRot = _cameraTrans.localEulerAngles;\n\n        // 非同期演出開始\n        _ = RunOpeningAsync();\n    }\n\n    private async UniTask RunOpeningAsync()\n    {\n        await PlayOpeningIntroAsync();\n        PlayCountdownSequence();\n    }\n\n    /// <summary>\n    /// 演出前半（カメラの移動・回転）\n    /// </summary>\n    private async UniTask PlayOpeningIntroAsync()\n    {\n        await UniTask.Delay(TimeSpan.FromSeconds(0.3f));\n        _tileChange.OnNext(Unit.Default);\n\n        _cameraTrans.DOMoveX(3, 2.9f);\n        _cameraTrans.DOBlendableRotateBy(new Vector3(0, 40, 0), 2.9f);\n\n        await UniTask.Delay(TimeSpan.FromSeconds(3));\n        _countTxt.enabled = true;\n    }\n\n    /// <summary>\n    /// カウントダウン演出\n    /// </summary>\n    private void PlayCountdownSequence()\n    {\n        Sequence sequence = DOTween.Sequence();\n\n        AddCountdownStep(sequence, \"3\",\n            startPos: new Vector3(5, 3, 3),\n            startRot: new Vector3(0, 220, 0),\n            moveTarget: new Vector3(3.8f, 3, 4.5f));\n\n        AddCountdownStep(sequence, \"2\",\n            startPos: new Vector3(-2, 2, -6),\n            startRot: new Vector3(0, 40, 0),\n            moveTarget: new Vector3(-5, 2, -3));\n\n        AddCountdownStep(sequence, \"1\",\n            startPos: new Vector3(0, 2, 6),\n            startRot: new Vector3(0, 180, 0));\n\n        // GO!!\n        sequence.AppendCallback(() => SetText(\"GO!!\"));\n        sequence.AppendCallback(() => _goSignal.OnNext(Unit.Default));\n        sequence.AppendCallback(() => _countTxt.transform.localScale = Vector3.zero);\n        sequence.Append(_countTxt.transform.DOScale(1, 1).SetEase(Ease.OutElastic));\n        sequence.Join(_cameraTrans.DOMove(new Vector3(0, 21, 23), 1));\n        sequence.Join(_cameraTrans.DOLocalRotate(new Vector3(30, 180, 0), 1));\n\n        sequence.OnComplete(() =>\n        {\n            _countTxt.enabled = false;\n            _openingEnd.OnNext(Unit.Default);\n        });\n\n        sequence.Play();\n    }\n\n    /// <summary>\n    /// カウントダウンの1ステップを追加\n    /// </summary>\n    private void AddCountdownStep(Sequence seq, string text, Vector3 startPos, Vector3 startRot, Vector3? moveTarget = null)\n    {\n        seq.AppendCallback(() =>\n        {\n            SetText(text);\n            SetCameraStart(startPos, startRot);\n        });\n\n        seq.Append(_countTxt.transform.DOScale(1, 1).SetEase(Ease.OutElastic));\n\n        if (moveTarget.HasValue)\n        {\n            seq.Join(_cameraTrans.DOMove(moveTarget.Value, 1));\n        }\n    }\n\n    private void SetCameraStart(Vector3 pos, Vector3 rot)\n    {\n        _countTxt.transform.localScale = Vector3.zero;\n        _cameraTrans.position = pos;\n        _cameraTrans.localEulerAngles = rot;\n    }\n\n    private void SetText(string txt) => _countTxt.text = txt;\n\n    private void OnDestroy()\n    {\n        // カメラを初期状態に戻す\n        _cameraTrans.position = _initialPos;\n        _cameraTrans.localEulerAngles = _initialRot;\n    }\n}\n", "__main_CameraWorking_cs": "using System.Collections.Generic;\nusing UnityEngine;\nusing System;\nusing Dreamteck.Splines;\nusing UnityEngine.Splines;\nusing DG.Tweening;\nusing Cysharp.Threading.Tasks;\nusing System.Threading;\n\nnamespace Sugoroku\n{\n    public class CameraWorking : MonoBehaviour\n    {\n        [SerializeField] Transform _target;\n        [SerializeField] Transform _mainCameraTrans;\n        [SerializeField] GameObject CameraParent;\n\n        private Vector3 _defaultPos;\n        private SplineAnimate _splineAnime;\n        private Transform _moveTrans;\n        private CancellationTokenSource _standbyCts;\n\n        void Start()\n        {\n            var obj = new GameObject();\n            _moveTrans = obj.transform;\n            _splineAnime = CameraParent.GetComponent<SplineAnimate>();\n\n            _splineAnime.enabled = false;\n        }\n\n        /// <summary>\n        /// スタート演出終了でスタンバイカメラワーク開始\n        /// </summary>\n        public void BeginningWork()\n        {\n            _mainCameraTrans.transform.parent = CameraParent.transform;\n            _mainCameraTrans.localPosition = Vector3.zero;\n            StartStandbyCameraLoop();\n        }\n\n        /// <summary>\n        /// スタンバイ中のカメラモーション開始\n        /// </summary>\n        private void StartStandbyCameraLoop()\n        {\n            _splineAnime.enabled = true;\n            _standbyCts?.Cancel();\n            _standbyCts = new CancellationTokenSource();\n            StandbyCameraLoopAsync(_standbyCts.Token).Forget();\n        }\n\n        /// <summary>\n        /// スタンバイ中のカメラモーション停止\n        /// </summary>\n        public void StopStandbyCameraLoop()\n        {\n            _splineAnime.enabled = false;\n            _standbyCts?.Cancel();\n        }\n\n        private async UniTaskVoid StandbyCameraLoopAsync(CancellationToken token)\n        {\n            while (!token.IsCancellationRequested)\n            {\n                if (_target != null)\n                {\n                    _mainCameraTrans.transform.LookAt(_target);\n                }\n\n                await UniTask.Yield(PlayerLoopTiming.Update, token);\n            }\n        }\n\n        /// <summary>\n        /// サイコロを振った際に移動演出を開始する\n        /// </summary>\n        public void BeginDiceRollEvent(int pieceTileIndex)\n        {\n            _defaultPos = _mainCameraTrans.transform.position;\n            StopStandbyCameraLoop();\n            UpdateCameraTargetByTileIndex(pieceTileIndex);\n            _mainCameraTrans.DOMove(_moveTrans.position, 1);\n            _mainCameraTrans.DORotate(_moveTrans.eulerAngles, 1);\n        }\n\n        /// <summary>\n        ///  ターンが終了した際にカメラを元の状態に戻す\n        /// </summary>\n        public void EndDiceRollEvent()\n        {\n            StartStandbyCameraLoop();\n            _mainCameraTrans.DOMove(_defaultPos, 1);\n        }\n\n        /// <summary>\n        /// 駒の位置に追従してカメラを移動する\n        /// </summary>\n        /// <param name=\"number\"></param>\n        public void MoveToPiecePosition(int number)\n        {\n            UpdateCameraTargetByTileIndex(number);\n            _mainCameraTrans.DOMove(_moveTrans.position, .3f).SetEase(Ease.InQuad);\n            _mainCameraTrans.DORotate(_moveTrans.eulerAngles, .3f).SetEase(Ease.InQuad);\n        }\n\n        /// <summary>\n        /// 駒の位置からカメラの目標座標・角度を決定する\n        /// </summary>\n        /// <param name=\"number\"></param>\n        private void UpdateCameraTargetByTileIndex(int number)\n        {\n            Vector3 pos;\n            int rotateY;\n\n            const int rotateX = 35;\n\n            if (number <= 9)\n            {\n                pos = new Vector3(12, 7, 0);\n                rotateY = -90;\n            }\n            else if (number <= 18)\n            {\n                pos = new Vector3(0, 7, -12);\n                rotateY = 0;\n            }\n            else if (number <= 27)\n            {\n                pos = new Vector3(-12, 7, 0);\n                rotateY = 90;\n            }\n            else if (number <= 36)\n            {\n                pos = new Vector3(0, 7, 12);\n                rotateY = 180;\n            }\n            else\n            {\n                throw new ArgumentOutOfRangeException(nameof(number), $\"Invalid number: {number}\");\n            }\n\n            _moveTrans.position = pos;\n            _moveTrans.eulerAngles = new Vector3(rotateX, rotateY, 0);\n        }\n    }\n}\n", "__main_RollingDice_cs": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing Cysharp.Threading.Tasks;\nusing DG.Tweening;\nusing UniRx;\n\nnamespace Sugoroku\n{\n    public class RollingDice : MonoBehaviour\n    {\n        private const float ROLL_TIME = 1f; //rサイコロの回転を見せる時間\n        private const float RESULT_TIME = 1f; //rサイコロの結果を見せる時間\n\n\n        [SerializeField] private List<Sprite> _diceSprites; // 0〜5: サイコロ目1〜6\n        [SerializeField] private Image _diceDisplay;\n        [SerializeField] private Button _diceBtn;\n        [SerializeField] private Button _testBtn;\n\n\n        private readonly Subject<int> _diceResult = new Subject<int>();\n        public IObservable<int> DiceResult => _diceResult;\n\n        private readonly Subject<Unit> _startDiceRoll = new Subject<Unit>();\n        public IObservable<Unit> StartDiceRoll => _startDiceRoll;\n\n        private void Start()\n        {\n            _diceDisplay.enabled = false;\n            _diceBtn.onClick.AddListener(() => _ = StartDiceRollAsync());\n        }\n\n        /// <summary>\n        /// サイコロのロール全体処理\n        /// </summary>\n        private async UniTaskVoid StartDiceRollAsync()\n        {\n            _diceDisplay.enabled = true;\n            _startDiceRoll.OnNext(Unit.Default);\n\n            int result = await AnimateDiceRollingAsync(TimeSpan.FromSeconds(ROLL_TIME));\n            await ShowResultAsync(result, TimeSpan.FromSeconds(RESULT_TIME));\n\n            _diceDisplay.enabled = false;\n            _diceResult.OnNext(result);\n        }\n\n        /// <summary>\n        /// 指定時間、ランダムにサイコロの目を変化させる\n        /// </summary>\n        /// <param name=\"duration\">アニメーション時間</param>\n        /// <returns　int = currentResult> サイコロの目の結果</returns>\n        private async UniTask<int> AnimateDiceRollingAsync(TimeSpan duration)\n        {\n            float endTime = Time.time + (float)duration.TotalSeconds;\n            int currentResult = 1;\n\n            while (Time.time < endTime)\n            {\n                currentResult = UnityEngine.Random.Range(1, 7);\n                SetDiceFace(currentResult);\n                await UniTask.Delay(TimeSpan.FromSeconds(0.1));\n            }\n\n            return currentResult;\n        }\n\n        /// <summary>\n        /// 指定された目を表示したまま一定時間表示する\n        /// </summary>\n        /// <param name=\"diceNumber\">出目</param>\n        /// <param name=\"duration\">公開時間</param>\n        private async UniTask ShowResultAsync(int diceNumber, TimeSpan duration)\n        {\n            SetDiceFace(diceNumber);\n            await UniTask.Delay(duration);\n        }\n\n        /// <summary>\n        ///  サイコロのスプライトを変更する（1〜6を0〜5に変換）\n        /// </summary>\n        /// <param name=\"diceNumber\">出目</param>\n        private void SetDiceFace(int diceNumber)\n        {\n            int index = Mathf.Clamp(diceNumber - 1, 0, _diceSprites.Count - 1);\n            _diceDisplay.sprite = _diceSprites[index];\n        }\n    }\n}\n", "__main_SugorokuPresenter_cs": "using System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing Cysharp.Threading.Tasks;\nusing DG.Tweening;\nusing UniRx;\n\nnamespace Sugoroku\n{\n  public class SugorokuPresenter : MonoBehaviour\n  {\n    [SerializeField] private SugorokuModel _sugorokuModel;\n    [SerializeField] private TileManager _tileManager;\n    [SerializeField] private SugorokuAnime _sugorokuAnime;\n    [SerializeField] private RollingDice _rollingDice;\n    [SerializeField] private PieceMoving _pieceMoving;\n    [SerializeField] private CameraWorking _cameraWorking;\n    [SerializeField] private GameOpening _gameOpening;\n\n    void Start()\n    {\n      //スタート演出でのタイル更新\n      _gameOpening.TileChange.Subscribe(_ =>\n      {\n        Debug.Log(\"enter1\");\n        _tileManager.UpdateTiles();\n      }).AddTo(this);\n\n      //発進合図\n      _gameOpening.GoSignal.Subscribe(async _ =>\n      {\n        Debug.Log(\"enter2\");\n        _tileManager.RoadMoving(true);\n        await _sugorokuAnime.StartAnimation();\n      }).AddTo(this);\n\n      //ゲームのスタート演出終了合図\n      _gameOpening.OpeningEnd.Subscribe(_ =>\n      {\n        Debug.Log(\"enter3\");\n        // _cameraWorking.StartStandbyCameraLoop();\n        _cameraWorking.BeginningWork();\n      }).AddTo(this);\n\n\n      //サイコロを振り始める\n      _rollingDice.StartDiceRoll.Subscribe(_ =>\n      {\n        Debug.Log(\"enter4\");\n        _sugorokuModel.PieceTileIndex = _pieceMoving.CurrentTileIndex;\n        _cameraWorking.BeginDiceRollEvent(_sugorokuModel.PieceTileIndex);\n      }).AddTo(this);\n\n      //Pieceの動き終了\n      _pieceMoving.IsPieceMove.Skip(1).Subscribe(value =>\n      {\n        Debug.Log(\"enter5\");\n        if (!value)\n        {\n          _cameraWorking.EndDiceRollEvent();\n        }\n      }).AddTo(this);\n\n      //サイコロの目を取得\n      _rollingDice.DiceResult.Subscribe(number =>\n      {\n        Debug.Log(\"enter6\");\n        _sugorokuModel.DiceValue = number;\n        _sugorokuModel.DiceTotal += _sugorokuModel.DiceValue;\n\n        _pieceMoving.ProceedPiece(_sugorokuModel.DiceValue);\n      }).AddTo(this);\n\n      //コマ位置での、中心床のマテリアル変化合図\n      _pieceMoving.RoadChange.Subscribe(value =>\n      {\n        Debug.Log(\"enter7\");\n        _tileManager.ChangeRoadVisual(value.Item1, value.Item2);\n        _cameraWorking.MoveToPiecePosition(value.Item2);\n      }).AddTo(this);\n\n      //次に進むTileを取得\n      _pieceMoving.GetTile.Subscribe(_ =>\n      {\n        Debug.Log(\"enter8\");\n        _pieceMoving.Tiles = _tileManager.Tiles;\n      }).AddTo(this);\n\n    }\n  }\n\n}\n"}
